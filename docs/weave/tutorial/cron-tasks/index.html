<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Scheduled Tasks · IOV Documentations</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="In almost every real-time software, the need to schedule jobs to be executed at a certain time in the"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Scheduled Tasks · IOV Documentations"/><meta property="og:type" content="website"/><meta property="og:url" content="https://docs.iov.one/"/><meta property="og:description" content="In almost every real-time software, the need to schedule jobs to be executed at a certain time in the"/><meta property="og:image" content="https://docs.iov.one/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://docs.iov.one/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/logo.png" alt="IOV Documentations"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="https://github.com/iov-one" target="_self">GitHub</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Tutorial</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Introduction<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/intro">Welcome to IOV!</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">IOV Name Service<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">Validator</h4><ul><li class="navListItem"><a class="navItem" href="/docs/iov-name-service/validator/rewards">Rewards</a></li><li class="navListItem"><a class="navItem" href="/docs/iov-name-service/validator/testnet">Testnet</a></li><li class="navListItem"><a class="navItem" href="/docs/iov-name-service/validator/mainnet">Mainnet</a></li><li class="navListItem"><a class="navItem" href="/docs/iov-name-service/validator/troubleshooter">Troubleshooter</a></li><li class="navListItem"><a class="navItem" href="/docs/iov-name-service/validator/faq">FAQ</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">Clients</h4><ul><li class="navListItem"><a class="navItem" href="/docs/iov-name-service/clients/iov-core">IOV Core</a></li><li class="navListItem"><a class="navItem" href="/docs/iov-name-service/clients/rest-api">REST API</a></li></ul></div></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">IOV Weave SDK<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/weave/welcome">Welcome</a></li><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">Basics</h4><ul><li class="navListItem"><a class="navItem" href="/docs/weave/basics/blockchain">Blockchain</a></li><li class="navListItem"><a class="navItem" href="/docs/weave/basics/consensus">Consensus</a></li><li class="navListItem"><a class="navItem" href="/docs/weave/basics/authentication">Authentication</a></li><li class="navListItem"><a class="navItem" href="/docs/weave/basics/state">State Machine</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">Design</h4><ul><li class="navListItem"><a class="navItem" href="/docs/weave/design/overview">Guiding Design Principles</a></li><li class="navListItem"><a class="navItem" href="/docs/weave/design/extension">Extension</a></li><li class="navListItem"><a class="navItem" href="/docs/weave/design/transaction-flow">Flow of Transactions</a></li><li class="navListItem"><a class="navItem" href="/docs/weave/design/permissions">Permissions</a></li><li class="navListItem"><a class="navItem" href="/docs/weave/design/queries">Queries</a></li><li class="navListItem"><a class="navItem" href="/docs/weave/design/prototool">Prototool</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">Configuration</h4><ul><li class="navListItem"><a class="navItem" href="/docs/weave/configuration/application">Application</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">API specifications</h4><ul><li class="navListItem"><a class="navItem" href="/docs/weave/weave-api-spec/address-derivation">Address Derivation</a></li><li class="navListItem"><a class="navItem" href="/docs/weave/weave-api-spec/weave-transaction-spec">Weave Transactions</a></li><li class="navListItem"><a class="navItem" href="/docs/weave/weave-api-spec/tx-sign-spec">Transaction Signatures</a></li><li class="navListItem"><a class="navItem" href="/docs/weave/weave-api-spec/weave-query-spec">Querying Weave</a></li><li class="navListItem"><a class="navItem" href="/docs/weave/weave-api-spec/modules">Modules</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">Tutorial</h4><ul><li class="navListItem"><a class="navItem" href="/docs/weave/tutorial/installation">Installation</a></li><li class="navListItem"><a class="navItem" href="/docs/weave/tutorial/domain">Domain</a></li><li class="navListItem"><a class="navItem" href="/docs/weave/tutorial/codec">Codec</a></li><li class="navListItem"><a class="navItem" href="/docs/weave/tutorial/models">Models</a></li><li class="navListItem"><a class="navItem" href="/docs/weave/tutorial/messages">Messages</a></li><li class="navListItem"><a class="navItem" href="/docs/weave/tutorial/buckets">Buckets</a></li><li class="navListItem"><a class="navItem" href="/docs/weave/tutorial/handlers">Handlers</a></li><li class="navListItem"><a class="navItem" href="/docs/weave/tutorial/app-level-codec">Application Level Codec</a></li><li class="navListItem"><a class="navItem" href="/docs/weave/tutorial/application">Application</a></li><li class="navListItem"><a class="navItem" href="/docs/weave/tutorial/batch-txs">Batch Transactions</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/weave/tutorial/cron-tasks">Scheduled Tasks</a></li></ul></div></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">IOV Core<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/iov-core-tutorial/introduction">Introduction</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Scheduled Tasks</h1></header><article><div><span><p>In almost every real-time software, the need to schedule jobs to be executed at a certain time in the
future is constant. In the blockchain context, this could be sending tokens, distributing revenue,
scheduling a proposal, basically anything that could be executed as a transaction (a change of
state). The early generation of blockchain protocols had a hard time assuring the execution time
of a transaction precisely, and this is due to the indeterministic nature of the consensus algorithms.
One of the wonders of Tendermint Consensus engine is the ability to roughly approximate the execution time of a
future block thanks to the <strong>BFT Time feature</strong>.
<a href="https://github.com/tendermint/tendermint/blob/v0.32.7/docs/spec/consensus/bft-time.md">Tendermint BFT Time</a>
document is a very technical and specification, but long story short, the execution time of a proposed block is
get by calculating the median of the latest block's commit voting times.</p>
<p>We achieved scheduled tasks functionalities by developing the module called
<a href="https://github.com/iov-one/weave/tree/master/x/cron">x/cron</a>. <a href="https://en.wikipedia.org/wiki/CRON">CRON</a>
is designed to be no different than a regular message except the fact that CRON tasks are initiated by
a ticker and processed by a different handler that is not accessible from the route. This means CRON
execution happens in a separate stack than the <a href="/docs/weave/tutorial/application">application stack</a>. Actually
CRON is a minimal application stack with limited functionality and capabilities. Although this does
not mean CRON routes are not accessible or interactable from the application stack. A task could be triggered,
canceled, modified, and created by a message routed to a request handler.</p>
<p>Differences between application and CRON stack:</p>
<ul>
<li>Executing CRON messages is almost the same as executing a message in
the usual flow</li>
<li>CRON can use the same or a different router to handle
messages and therefore support the same or different set of messages</li>
<li>Using different handler allows configuring which messages can be processed by the same
handler and which message can be used both by the request handler and CRON handler</li>
<li>CRON use a different authentication policy</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="scheduler"></a><a href="#scheduler" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Scheduler</h3>
<p><a href="https://github.com/iov-one/weave/blob/master/cron.go#L43-L55">Scheduler interface</a> defines an
API to schedule a task for a time in the future with the conditions that are eligible to execute the
tasks.</p>
<pre><code class="hljs css language-go"><span class="hljs-comment">// Scheduler is an interface implemented to allow scheduling message execution.</span>
<span class="hljs-keyword">type</span> Scheduler <span class="hljs-keyword">interface</span> {
    <span class="hljs-comment">// Schedule queues given message in the database to be executed at</span>
    <span class="hljs-comment">// given time. Message will be executed with context containing</span>
    <span class="hljs-comment">// provided authentication addresses.</span>
    <span class="hljs-comment">// When successful, returns the scheduled task ID.</span>
    Schedule(KVStore, time.Time, []Condition, Msg) ([]<span class="hljs-keyword">byte</span>, error)

    <span class="hljs-comment">// Delete removes a scheduled task from the queue. It returns</span>
    <span class="hljs-comment">// ErrNotFound if task with given ID is not present in the queue.</span>
    Delete(KVStore, []<span class="hljs-keyword">byte</span>) error
}
</code></pre>
<p><strong>Warning:</strong> Due to the implementation details, the transaction is guaranteed to be executed after a
given time, but not exactly at a given time. If another transaction is already scheduled for the same time, the execution of this transaction is delayed until the next free slot.</p>
<p><strong>Important Note:</strong> An authentication address, Condition, is passed to the scheduler because, in
the usual flow, before processing the message, signature is validated to authenticate and later
authorize. In CRON this is not the case, because what a normal message creates is a new message that
says &quot;CRON do X&quot; and the signature of this message is not present in the context. It is
impossible to sign a message for scheduler without the private key.
Instead, the signature check step is bypassed and desired conditions are set in the context when
processing given scheduled message.</p>
<p>The absence of a signature could be a security hole if a developer implements the CRON feature poorly.
Happily, only code can schedule a CRON task and decide on conditions, so this should never be an
issue.</p>
<h3><a class="anchor" aria-hidden="true" id="ticker"></a><a href="#ticker" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Ticker</h3>
<p><a href="https://github.com/iov-one/weave/blob/master/cron.go#L11-L27">Ticker interface</a> defines the API
of the executor of the scheduled jobs.</p>
<pre><code class="hljs css language-go"><span class="hljs-comment">// Ticker is an interface used to call background tasks scheduled for</span>
<span class="hljs-comment">// execution.</span>
<span class="hljs-keyword">type</span> Ticker <span class="hljs-keyword">interface</span> {
    <span class="hljs-comment">// Tick is a method called at the beginning of the block. It should be</span>
    <span class="hljs-comment">// used to execute any scheduled tasks.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Because beginning of the block does not allow for an error response</span>
    <span class="hljs-comment">// this method does not return one as well. It is the implementation</span>
    <span class="hljs-comment">// responsibility to handle all error situations.</span>
    <span class="hljs-comment">// In case of an error that is an instance specific (ie database</span>
    <span class="hljs-comment">// issues) it might be neccessary for the method to terminate (ie</span>
    <span class="hljs-comment">// panic). An instance specific issue means that all other nodes most</span>
    <span class="hljs-comment">// likely succeeded processing the task and have different state than</span>
    <span class="hljs-comment">// this instance. This means that this node is out of sync with the</span>
    <span class="hljs-comment">// rest of the network and cannot continue operating as its state is</span>
    <span class="hljs-comment">// invalid.</span>
    Tick(ctx Context, store CacheableKVStore) TickResult
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="tutorial"></a><a href="#tutorial" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tutorial</h2>
<h3><a class="anchor" aria-hidden="true" id="message"></a><a href="#message" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Message</h3>
<p>In <a href="https://github.com/iov-one/blog-tutorial/blob/master/x/blog/codec.proto#L92-L104">CreateArticleMsg</a>
we defined a field named as <code>delete_at</code> that defines the deletion time of the article that will be executed by CRON. And the <code>task_id</code> variable
defines the ID of task generated by scheduler. Keeping the task ID accessible enables various modifications on the scheduled task such as deletion
after creation.</p>
<h3><a class="anchor" aria-hidden="true" id="scheduler-handler"></a><a href="#scheduler-handler" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Scheduler Handler</h3>
<pre><code class="hljs css language-go"><span class="hljs-keyword">type</span> CreateArticleHandler <span class="hljs-keyword">struct</span> {
    auth      x.Authenticator
    ab        *ArticleBucket
    bb        *BlogBucket
    scheduler weave.Scheduler
}
</code></pre>
<p><em>weave.Scheduler</em> will be initiated and passed to the handler on the stack layer.</p>
<p><a href="https://github.com/iov-one/blog-tutorial/blob/master/x/blog/handler.go#L358-L363">The code</a> that
schedules a job to be processed in future is below:</p>
<pre><code class="hljs css language-go"><span class="hljs-comment">// schedule delete task</span>
    <span class="hljs-keyword">if</span> msg.DeleteAt != <span class="hljs-number">0</span> {
        deleteArticleMsg := &amp;DeleteArticleMsg{
            Metadata:   &amp;weave.Metadata{Schema: <span class="hljs-number">1</span>},
            ArticleKey: article.PrimaryKey,
        }

        taskID, err := h.scheduler.Schedule(store, article.DeleteAt.Time(), <span class="hljs-literal">nil</span>, deleteArticleMsg)
        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.Wrap(err, <span class="hljs-string">"cannot schedule deletion task"</span>)
        }

        article.DeleteTaskID = taskID
    }
</code></pre>
<p>If the create message contains a DeleteAt value, <code>deleteArticleMsg</code> will be initiated and
scheduled with no condition. Don't get scared by <strong>with no condition</strong> words, the CRON handler
is not routed to the outer world anyway. Yet you can enable this access with registering the CRON handler to a <code>QueryHandler</code>. It is a design and requirement choice.</p>
<p>Let's say we want a message that could be executed only when an <strong>admin's</strong> condition is present
in the context. For this, the handler that will execute message must check if the admin's
condition is in the context and then execute accordingly. To pass this authentication
information to the CRON handler you need to feed the condition to the scheduler:</p>
<p><code>taskID, err = h.scheduler.Schedule(store, article.DeleteAt.Time(), adminCond, deleteArticleMsg)</code></p>
<p>In the code example above we also defined a <code>taskID</code> that will be used to identify the task among
other deletion tasks; with this information we can delete or modify the task after scheduling
process is over.</p>
<h2><a class="anchor" aria-hidden="true" id="executor-handler"></a><a href="#executor-handler" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Executor Handler</h2>
<p>Executor Handler in this context refers to the handler that will execute the task that is received from
the application ticker. We implemented the deletion scheduling logic within <code>CreateArticleHandler</code>,
now we have to implement the consumer logic, which is <code>CronDeleteArticleHandler</code>.</p>
<p><code>Deliver</code> method of <code>CronDeleteArticleHandler</code>:</p>
<pre><code class="hljs css language-go"><span class="hljs-comment">// Deliver stages a scheduled deletion if all preconditions are met</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h CronDeleteArticleHandler)</span> <span class="hljs-title">Deliver</span><span class="hljs-params">(ctx weave.Context, store weave.KVStore, tx weave.Tx)</span> <span class="hljs-params">(*weave.DeliverResult, error)</span></span> {
    msg, err := h.validate(ctx, store, tx)
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err
    }

    <span class="hljs-keyword">if</span> err := h.b.Delete(store, msg.ArticleKey); err != <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.Wrapf(err, <span class="hljs-string">"cannot delete article with ID %s"</span>, msg.ArticleKey)
    }

    <span class="hljs-keyword">return</span> &amp;weave.DeliverResult{}, <span class="hljs-literal">nil</span>
}
</code></pre>
<p>This handler will receive the <code>DeleteArticleMsg</code>, delete the article from the store using the
article ID data that is passed along with the message.</p>
<h2><a class="anchor" aria-hidden="true" id="task-cancellation"></a><a href="#task-cancellation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Task Cancellation</h2>
<p>If we need the ability to do execution in the distant future, we also need the ability to cancel the
same execution. As you remember we saved the scheduled task information to the store to be used
in various post-submission activities. Deletion is the simplest example of this case. As you have read
many many times, and probably got very used to, every action in Weave goes through a handler. We
will create a handler called <code>CancelDeleteArticleTaskHandler</code>.</p>
<pre><code class="hljs css language-go"><span class="hljs-comment">// validate does all common pre-processing between Check and Deliver</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h CancelDeleteArticleTaskHandler)</span> <span class="hljs-title">validate</span><span class="hljs-params">(ctx weave.Context, store weave.KVStore, tx weave.Tx)</span> <span class="hljs-params">(*CancelDeleteArticleTaskMsg, error)</span></span> {
    <span class="hljs-keyword">var</span> msg CancelDeleteArticleTaskMsg

    <span class="hljs-keyword">if</span> err := weave.LoadMsg(tx, &amp;msg); err != <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.Wrap(err, <span class="hljs-string">"load msg"</span>)
    }

    <span class="hljs-keyword">var</span> task DeleteArticleTask
    <span class="hljs-keyword">if</span> err := h.b.One(store, msg.TaskID, &amp;task); err != <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.Wrapf(err, <span class="hljs-string">"delete task with id %s not found"</span>, msg.TaskID)
    }

    signer := x.MainSigner(ctx, h.auth).Address()
    <span class="hljs-keyword">if</span> !task.TaskOwner.Equals(signer) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.Wrapf(errors.ErrUnauthorized, <span class="hljs-string">"signer %s is unauthorized to cancel scheduled delete article task with id %s"</span>, signer, msg.TaskID)
    }

    <span class="hljs-keyword">return</span> &amp;msg, <span class="hljs-literal">nil</span>
}
</code></pre>
<p>Since cancellation of tasks must be initiated by a user-signed message, we need to
check explicitly if the user signature is in the context, same as every other regular handler.</p>
<p>If the task you want to cancel exists and the task owner is the signer of the address, execution
proceeds to the <code>Deliver</code> method:</p>
<pre><code class="hljs css language-go"><span class="hljs-comment">// Deliver cancels delete task if conditions are met</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h CancelDeleteArticleTaskHandler)</span> <span class="hljs-title">Deliver</span><span class="hljs-params">(ctx weave.Context, store weave.KVStore, tx weave.Tx)</span> <span class="hljs-params">(*weave.DeliverResult, error)</span></span> {
    _, article, err := h.validate(ctx, store, tx)
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err
    }

    <span class="hljs-keyword">if</span> err := h.scheduler.Delete(store, article.DeleteTaskID); err != <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.Wrapf(err, <span class="hljs-string">"cannot deschedule with task id %s"</span>, article.DeleteTaskID)
    }

    article.DeleteTaskID = <span class="hljs-literal">nil</span>
    <span class="hljs-keyword">if</span> err := h.b.Save(store, article); err != <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.Wrapf(err, <span class="hljs-string">"cannot update article %s "</span>, article.PrimaryKey)
    }

    <span class="hljs-keyword">return</span> &amp;weave.DeliverResult{}, <span class="hljs-literal">nil</span>
}
</code></pre>
<p>First, the task gets <strong>descheduled</strong> using the task ID present in the article and then set as nil in article model</p>
<h2><a class="anchor" aria-hidden="true" id="cron-stack"></a><a href="#cron-stack" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CRON Stack</h2>
<p>As we mentioned before, CRON handlers are no different than regular handlers but they differ in
one point: CRON operates in a totally different stack than the application.</p>
<p>We need to define a separate route for our CRON stack in the blog module:</p>
<pre><code class="hljs css language-go"><span class="hljs-comment">// RegisterCronRoutes registers routes that are not exposed to</span>
<span class="hljs-comment">// routers</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RegisterCronRoutes</span><span class="hljs-params">(
    r weave.Registry,
    auth x.Authenticator,
)</span></span> {
    r.Handle(&amp;DeleteArticleMsg{}, newCronDeleteArticleHandler(auth))
}
</code></pre>
<p>And then we need to decorate cron route handlers with utilizations.</p>
<pre><code class="hljs css language-go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CronStack</span><span class="hljs-params">()</span> <span class="hljs-title">weave</span>.<span class="hljs-title">Handler</span></span> {
    rt := app.NewRouter()

    authFn := cron.Authenticator{}

    <span class="hljs-comment">// Cron is using custom router as not the same handlers are registered.</span>
    blog.RegisterCronRoutes(rt, authFn)

    decorators := app.ChainDecorators(
        utils.NewLogging(),
        utils.NewRecovery(),
        utils.NewKeyTagger(),
        utils.NewActionTagger(),
        <span class="hljs-comment">// No fee decorators.</span>
    )
    <span class="hljs-keyword">return</span> decorators.WithHandler(rt)
}
</code></pre>
<p>And last we need a <code>Ticker</code> that will process the scheduled messages:</p>
<pre><code class="hljs css language-go">ticker := cron.NewTicker(CronStack(), CronTaskMarshaler)
</code></pre>
<p>Feed the ticker to the base application:</p>
<pre><code class="hljs css language-go"><span class="hljs-comment">// Application constructs a basic ABCI application with</span>
<span class="hljs-comment">// the given arguments.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Application</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>, h weave.Handler,
    tx weave.TxDecoder, dbPath <span class="hljs-keyword">string</span>, debug <span class="hljs-keyword">bool</span>)</span> <span class="hljs-params">(app.BaseApp, error)</span></span> {

    ctx := context.Background()
    kv, err := CommitKVStore(dbPath)
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">return</span> app.BaseApp{}, errors.Wrap(err, <span class="hljs-string">"cannot create database instance"</span>)
    }
    store := app.NewStoreApp(name, kv, QueryRouter(), ctx)
    base := app.NewBaseApp(store, tx, h, ticker, debug)
    <span class="hljs-keyword">return</span> base, <span class="hljs-literal">nil</span>
}
</code></pre>
<p>When the application is run, CRON stack will be initialized by the <code>Application</code> method and will be consuming tasks.</p>
</span></div></article></div><div class="docLastUpdate"><em>Last updated by Orkun Külçe</em></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/weave/tutorial/batch-txs"><span class="arrow-prev">← </span><span>Batch Transactions</span></a><a class="docs-next button" href="/docs/iov-core-tutorial/introduction"><span>Introduction</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#tutorial">Tutorial</a><ul class="toc-headings"><li><a href="#message">Message</a></li><li><a href="#scheduler-handler">Scheduler Handler</a></li></ul></li><li><a href="#executor-handler">Executor Handler</a></li><li><a href="#task-cancellation">Task Cancellation</a></li><li><a href="#cron-stack">CRON Stack</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"></a><div><h5>Docs</h5><a href="/docs/iov-name-service/validator/rewards">IOV Name Service</a><a href="/docs/weave/welcome">Weave</a></div><div><h5>Community</h5><a href="https://riot.im/app/#/room/#weave:matrix.org" target="_blank">Riot Chat</a><a href="https://t.me/internetofvalues" target="_blank">Telegram</a><a href="https://twitter.com/iov_official" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="https://github.com/iov-one" target="_blank">GitHub</a><a href="https://www.iov.one" target="_blank">Website</a></div></section><section class="copyright">Copyright © 2019 IOV</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '8dc8128a9091306e7bbd0effdaa5241a',
                indexName: 'iov',
                inputSelector: '#search_input_react'
              });
            </script></body></html>