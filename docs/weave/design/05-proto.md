---
id: prototool
title: Prototool
sidebar_label: Prototool
---

At IOV, we use [prototool](https://github.com/iov-one/prototool-docker) for linting, formatting, and generating protobuf files. It is highly convenient and easy to use. Generating `*.pb.go` files are as easy as running `make protoc` with Makefile script. Configuration is easier; just edit `prototool.yaml` or `prototool.json`.

Here is the [prototool.yaml](https://github.com/iov-one/weave-starter-kit/blob/master/prototool.yaml) from **weave-starter-kit**:

```yaml
protoc:
  version: 3.7.1 # Defines which version of protoc to use

  # If not set, compile will fail if there are unused imports.
  # Setting this will ignore unused imports.
  allow_unused_imports: false

  # Import parths
  includes:
    - .
    - /usr/include
    - spec
    - spec/github.com/iov-one/weave

# excluded paths
excludes:
  - .git
  - spec

generate:
  go_options:
    import_path: github.com/iov-one/weave-starter-kit

  plugins:
    - name: gogofaster # Indicates gogofaster will be used.
      type: gogo
      output: .

lint:
  rules:
    remove:
      - FILE_OPTIONS_REQUIRE_JAVA_MULTIPLE_FILES
      - FILE_OPTIONS_REQUIRE_JAVA_OUTER_CLASSNAME
      - FILE_OPTIONS_REQUIRE_JAVA_PACKAGE
      - FILE_OPTIONS_REQUIRE_GO_PACKAGE
```

- `includes` field contains which import paths will be used when running protoc.

  - `.` means that `import "x/custom/codec.go"` will work inside this app (recommended to avoid GOPATH issues)
  - `spec` means that we can `import "github.com/iov-one/weave/coins/codec.proto"` and it will use the protobuf file from our spec directory (which must be kept up to date with the Weave repo).
  - `spec/github.com/iov-one/weave` is needed as if we import eg. `github.com/iov-one/weave/x/cash/codec.proto`, it imports `coins/codec.proto` using relative imports to it's project. When we then import this via spec, the relative import doesn't work without this second line.

- `excludes` field contains which paths to exclude when compiling protobuf. `spec` directory contains the Weave codecs that will be used in modules, so no need to compile these.

```yaml
generate:
  go_options:
    import_path: github.com/iov-one/weave-starter-kit
```

- The base import path. This should be the go path of the prototool.yaml file. This is required if you have any go plugins.

```yaml
plugins:
  - name: gogofaster # Indicates gogofaster will be used.
    type: gogo
    output: .
```

- This part tells prototool to use `gogofaster` plugin and output is current directory.
  You are welcome to use other codecs than `gogofaster`, you can also try the standard Go language protobuf compiler. What this mode goes is auto-generate static code for serialization and deserialization of the type. It performs the introspection one time to generate efficient code allowing us to avoid the use of reflection at runtime and get ~10x speed ups in the serialization/deserialization. I like this, but this may vary based on your preference or aversion of auto-generated code.

- `lint` field defines the linting rules. Extra rules could be added if desired.

After defining your state and messages run `make protoc`. This script will download `prototool` docker image and compile codec.proto file `codec.pb.go` file.
Now we have the scaffold of our application thanks to the auto-generated _codec.pb.go_ file.

### Using Autogenerated Structs

The first time through the above process may appear tedious, but once you get the hang of it, you just have to add a few lines to a _.proto_ file and type `make protoc`. Et voila! You have a bunch of fresh \*.pb.go files that provide efficient, portable serialization for your code.

But how do you use those structs? Taking `User` from [x/blog/codec.proto](https://github.com/iov-one/blog-tutorial/blob/master/x/blog/codec.proto#L10-L20) as an example, we see a `x/blog/codec.pb.go` file with `type User struct {...}` that closely mirrors the content of the codec.proto file, as well as many of the methods. There are some auto-generated getters, which can be useful to fulfill interfaces or to query field of _nil_ objects without panicking. And then there are some (very long) **Marshal** and **Unmarshal** methods. These are the meat of the matter. They fulfill the Persistent interface and let us write code like this:

```go
orig := User{...}
bz, err := orig.Marshal()
parsed := User{}
err = parsed.Unmarshal(bz)
```

This is fine, but what happens when I want to add custom logic to my User struct, perhaps adding validation logic, or code to add two coins? Luckily for us, Go allows you two write methods for your structs in any file in the same package. That means that we can just inherit the struct definition and all the serialization logic and just append the methods we care about. [x/blog/model.go](https://github.com/iov-one/blog-tutorial/blob/master/x/blog/model.go#L15-L18) is a great example of extending the functionality, with code like:

```go
func (u *User) IsRegisteredAfterDate(date time.Time) bool {
  return u.RegisteredAt.Time().After(date)
}
```

This is a productive workflow and I recommend trying it out. You may find it doesnâ€™t work for you and you can try other approaches, like copying the protobuf generated structs into some custom-written structs you like and then copying back into protobuf structs for serialization. You can also try playing with special [protobuf extensions](https://github.com/gogo/protobuf/blob/master/extensions.md) flags in your protobuf files to shape the auto-generated code into the exact shape you want.

### Notes About oneof

**oneof** is a powerful feature to produce union/sum types in your protobuf structures. For example, you may have a public key which may be one of many different algorithms and can define cases for each, which can be switched on in runtime. We also use this for the transaction to enumerate a set of possible messages that can be embedded in the transaction. A transaction may have any one of them and serialize and deserialize properly. Type-safety is enforced in compile-time and we can switch on the kind at runtime. (Example from [bcp-demo](https://github.com/iov-one/bcp-demo/blob/master/app/codec.proto)):

```protobuf
oneof sum {
  cash.SendMsg cash_send_msg = 51;
  multisig.CreateMsg multisig_create_msg = 56;
  multisig.UpdateMsg multisig_update_msg = 57;
  validators.ApplyDiffMsg validators_apply_diff_msg = 58;
  ExecuteBatchMsg execute_batch_msg = 60;
  migration.UpgradeSchemaMsg migration_upgrade_schema_msg = 69;
  blog.CreateUserMsg blog_create_user_msg = 100;
  blog.CreateBlogMsg blog_create_blog_msg = 101;
  blog.ChangeBlogOwnerMsg blog_change_blog_owner_msg = 102;
  blog.CreateArticleMsg blog_create_article_msg = 103;
  blog.DeleteArticleMsg blog_delete_article_msg = 104;
  blog.CancelDeleteArticleTaskMsg blog_cancel_delete_article_task_msg = 105;
}
```

The only problem is that, to some people, the generated code is ugly. This derives from the fact that there is no clean way to express sum types in Go, and you have to force an interface with private methods to close the set of possible types. Although some people have been so revolted by this code that they preferred to [write their own serialization library](https://github.com/tendermint/go-amino 'go-amino'), I would suggest just taking a deep breath and getting to know it. Here are the relevant pieces:

```go
type Tx struct {
  // Types that are valid to be assigned to Sum:
  //  *Tx_CashSendMsg
	//	*Tx_MultisigCreateMsg
	//	*Tx_MultisigUpdateMsg
	//	*Tx_ValidatorsApplyDiffMsg
	//	*Tx_ExecuteBatchMsg
	//	*Tx_MigrationUpgradeSchemaMsg
	//	*Tx_BlogCreateUserMsg
	//	*Tx_BlogCreateBlogMsg
	//	*Tx_BlogChangeBlogOwnerMsg
	//	*Tx_BlogCreateArticleMsg
	//	*Tx_BlogDeleteArticleMsg
	//	*Tx_BlogCancelDeleteArticleTaskMsg
	Sum isTx_Sum `protobuf_oneof:"sum"`
}
```

We now have some intermediate structs that give us a layer of unidirection in order to enforce the fact we can now securely switch over all possible `tx.Sum` fields, with [code like this](https://github.com/iov-one/bcp-demo/blob/master/app/tx.go#L33-61):

```go
sum := tx.GetSum()
switch t := sum.(type) {
case *Tx_SendMsg:
    return t.SendMsg, nil
case *Tx_SetNameMsg:
    return t.SetNameMsg, nil
case *Tx_CreateTokenMsg:
    return t.CreateTokenMsg, nil
case *Tx_CreateMsg:
    return t.CreateMsg, nil
case *Tx_ReleaseMsg:
    return t.ReleaseMsg, nil
case *Tx_ReturnMsg:
    return t.ReturnMsg, nil
case *Tx_UpdateEscrowMsg:
    return t.UpdateEscrowMsg, nil
}
```

